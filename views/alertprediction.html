<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Disaster Prediction Alert - EduSafe 360</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Inter', sans-serif;
      background: #0a1128;
      color: #e0e0e0;
      padding: 20px;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
    }

    h1 {
      text-align: center;
      margin-bottom: 20px;
      color: #007BFF;
    }

    .map-controls {
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
      flex-wrap: wrap;
    }

    #location-search {
      flex: 1;
      padding: 10px;
      border-radius: 8px;
      border: 1px solid #007BFF;
      background: #1a2540;
      color: white;
    }

    button {
      padding: 10px 20px;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-weight: bold;
      transition: background 0.3s;
    }

    #search-btn, #refresh-btn {
      background: #007BFF;
      color: white;
    }

    #search-btn:hover, #refresh-btn:hover {
      background: #0056b3;
    }

    .legend {
      display: flex;
      gap: 20px;
      margin-bottom: 20px;
      flex-wrap: wrap;
    }

    .color {
      display: inline-block;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      margin-right: 5px;
    }

    .red { background: #ff4d4d; }
    .yellow { background: #ffcc00; }
    .green { background: #4caf50; }

    #map-container {
      height: 600px;
      width: 100%;
      border-radius: 16px;
      margin-bottom: 30px;
      box-shadow: 0 4px 20px rgba(0, 123, 255, 0.2);
    }

    .info-panel {
      background: #1a2540;
      padding: 20px;
      border-radius: 16px;
      max-width: 400px;
      margin: 0 auto;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
    }

    .info-panel.hidden {
      display: none;
    }

    #forecast-btn {
      background: #28a745;
      color: white;
      margin-top: 15px;
    }

    #forecast-btn:hover {
      background: #218838;
    }

    .forecast {
      margin-top: 15px;
      padding: 15px;
      background: rgba(0,0,0,0.2);
      border-radius: 8px;
    }

    .forecast.hidden {
      display: none;
    }

    .forecast-item {
      margin: 10px 0;
      padding: 10px;
      background: rgba(255,255,255,0.1);
      border-radius: 8px;
    }

    .loading {
      display: none;
      text-align: center;
      padding: 10px;
      color: #007BFF;
    }
  </style>
  
  <!-- Leaflet CSS for OpenStreetMap -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
</head>

<body>
  <div class="container">
    <h1>Disaster Prediction Alert Map</h1>
    <div class="map-controls">
      <input type="text" id="location-search" placeholder="Search location...">
      <button id="search-btn">Search</button>
      <button id="refresh-btn">Refresh Data</button>
    </div>

    <div class="loading" id="loading">Searching location...</div>

    <div class="legend">
      <div><span class="color red"></span> Alert Zone (High Risk)</div>
      <div><span class="color yellow"></span> Caution Zone (Near Alert)</div>
      <div><span class="color green"></span> Safe Zone</div>
    </div>

    <div id="map-container"></div>

    <div id="info-panel" class="info-panel hidden">
      <h3>Location Details</h3>
      <p><strong>Location:</strong> <span id="location-name">-</span></p>
      <p><strong>Current Weather:</strong> <span id="current-weather">-</span></p>
      <p><strong>Temperature:</strong> <span id="temp">-</span>°C</p>
      <p><strong>Risk Level:</strong> <span id="risk-level">-</span></p>
      <button id="forecast-btn">View 7-Day Forecast</button>
      <div id="forecast-container" class="forecast hidden"></div>
    </div>
  </div>

  <!-- Leaflet JS for OpenStreetMap -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  
  <script>
    let map;
    let markers = [];
    let circles = [];
    let infoPanel = document.getElementById('info-panel');
    let forecastContainer = document.getElementById('forecast-container');
    let loadingIndicator = document.getElementById('loading');

    // Mock Alert Zones (in real app, fetch from backend or disaster API)
    const alertZones = [
      { center: { lat: 37.7749, lng: -122.4194 }, radius: 5000, level: 'red' },   // San Francisco
      { center: { lat: 34.0522, lng: -118.2437 }, radius: 8000, level: 'yellow' }, // LA
      { center: { lat: 40.7128, lng: -74.0060 }, radius: 3000, level: 'red' },     // NYC
    ];

    // Initialize Map with OpenStreetMap
    function initMap() {
      map = L.map('map-container').setView([39.8283, -98.5795], 5); // USA center
      
      // Add OpenStreetMap tiles
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '© OpenStreetMap contributors',
        maxZoom: 18
      }).addTo(map);

      // Draw Alert Zones
      drawAlertZones();

      // Add Click Listener
      map.on("click", (event) => {
        showLocationInfo(event.latlng);
      });

      // Setup Search
      document.getElementById('search-btn').addEventListener('click', searchLocation);
      document.getElementById('refresh-btn').addEventListener('click', refreshData);
      document.getElementById('forecast-btn').addEventListener('click', toggleForecast);
    }

    // Draw Circles for Alert Zones using Leaflet
    function drawAlertZones() {
      alertZones.forEach(zone => {
        const circle = L.circle([zone.center.lat, zone.center.lng], {
          color: getZoneColor(zone.level),
          fillColor: getZoneColor(zone.level),
          fillOpacity: 0.35,
          radius: zone.radius
        }).addTo(map);
        
        circles.push(circle);
      });
    }

    function getZoneColor(level) {
      switch(level) {
        case 'red': return '#ff4d4d';
        case 'yellow': return '#ffcc00';
        default: return '#4caf50';
      }
    }

    // Get Risk Level Based on Distance to Alert Zones
    function getRiskLevel(latLng) {
      for (let zone of alertZones) {
        // Calculate distance using Haversine formula
        const distance = calculateDistance(
          latLng.lat, latLng.lng, 
          zone.center.lat, zone.center.lng
        );
        
        if (distance <= zone.radius / 1000) { // Convert to km
          return zone.level;
        } else if (distance <= (zone.radius * 2) / 1000) {
          return 'yellow';
        }
      }
      return 'green';
    }

    // Haversine formula to calculate distance between two points
    function calculateDistance(lat1, lon1, lat2, lon2) {
      const R = 6371; // Earth's radius in km
      const dLat = (lat2 - lat1) * Math.PI / 180;
      const dLon = (lon2 - lon1) * Math.PI / 180;
      const a = 
        Math.sin(dLat/2) * Math.sin(dLat/2) +
        Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * 
        Math.sin(dLon/2) * Math.sin(dLon/2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
      return R * c; // Distance in km
    }

    // Show Info Panel for Clicked Location using OpenStreetMap Nominatim
    async function showLocationInfo(latLng) {
      showLoading(true);
      
      try {
        // Reverse geocoding with OpenStreetMap Nominatim (free, no API key needed)
        const response = await fetch(
          `https://nominatim.openstreetmap.org/reverse?format=json&lat=${latLng.lat}&lon=${latLng.lng}&zoom=10&addressdetails=1`
        );
        
        if (!response.ok) throw new Error('Geocoding failed');
        
        const data = await response.json();
        const address = data.display_name || 'Unknown location';

        // Get Weather
        const weather = await fetchWeather(latLng.lat, latLng.lng);
        const risk = getRiskLevel(latLng);

        // Update Panel
        document.getElementById('location-name').textContent = address;
        document.getElementById('current-weather').textContent = weather.description;
        document.getElementById('temp').textContent = weather.temp;
        document.getElementById('risk-level').textContent = risk;
        document.getElementById('risk-level').style.color = getZoneColor(risk);

        infoPanel.classList.remove('hidden');
        forecastContainer.classList.add('hidden'); // Reset forecast

        // Clear old markers
        markers.forEach(m => map.removeLayer(m));
        markers = [];

        // Add Marker with Leaflet
        const marker = L.circleMarker([latLng.lat, latLng.lng], {
          radius: 8,
          fillColor: getZoneColor(risk),
          color: '#fff',
          weight: 2,
          opacity: 1,
          fillOpacity: 1
        }).addTo(map);
        
        markers.push(marker);
        
      } catch (error) {
        console.error("Error getting location info:", error);
        alert("Could not retrieve location information. Please try again.");
      } finally {
        showLoading(false);
      }
    }

    // Fetch Weather from OpenWeatherMap (free tier)
    async function fetchWeather(lat, lon) {
      const API_KEY = '74426455880a7d1226cfd4b255daf1ae';
      const url = `https://api.openweathermap.org/data/2.5/weather?lat=${lat}&lon=${lon}&units=metric&appid=${API_KEY}`;
      
      try {
        const response = await fetch(url);
        if (!response.ok) throw new Error('Weather API error');
        
        const data = await response.json();
        return {
          temp: Math.round(data.main.temp),
          description: data.weather[0].description
        };
      } catch (error) {
        console.error("Weather fetch error:", error);
        return { temp: '-', description: 'Unavailable' };
      }
    }

    // Toggle 7-Day Forecast
    async function toggleForecast() {
      const isVisible = forecastContainer.classList.contains('hidden');
      if (isVisible) {
        if (markers.length > 0) {
          const latLng = markers[0].getLatLng();
          await loadForecast(latLng.lat, latLng.lng);
          forecastContainer.classList.remove('hidden');
        }
      } else {
        forecastContainer.classList.add('hidden');
      }
    }

    // Load 7-Day Forecast
    async function loadForecast(lat, lon) {
      const API_KEY = '74426455880a7d1226cfd4b255daf1ae';
      const url = `https://api.openweathermap.org/data/2.5/forecast?lat=${lat}&lon=${lon}&units=metric&appid=${API_KEY}`;

      try {
        const response = await fetch(url);
        if (!response.ok) throw new Error('Forecast API error');
        
        const data = await response.json();
        forecastContainer.innerHTML = '';

        // Group by day
        const daily = data.list.filter((item, idx) => idx % 8 === 0); // Every 24h

        daily.slice(0, 7).forEach(day => {
          const date = new Date(day.dt * 1000).toLocaleDateString();
          const temp = Math.round(day.main.temp);
          const desc = day.weather[0].description;

          const div = document.createElement('div');
          div.className = 'forecast-item';
          div.innerHTML = `<strong>${date}</strong>: ${temp}°C, ${desc}`;
          forecastContainer.appendChild(div);
        });

      } catch (error) {
        forecastContainer.innerHTML = '<p>Forecast unavailable.</p>';
      }
    }

    // Search Location using OpenStreetMap Nominatim
    async function searchLocation() {
      const input = document.getElementById('location-search').value.trim();
      if (!input) return;

      showLoading(true);
      
      try {
        // Forward geocoding with OpenStreetMap Nominatim
        const response = await fetch(
          `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(input)}&limit=1`
        );
        
        if (!response.ok) throw new Error('Search failed');
        
        const data = await response.json();
        
        if (data.length === 0) {
          alert("Location not found.");
          return;
        }

        const result = data[0];
        const loc = { lat: parseFloat(result.lat), lng: parseFloat(result.lon) };
        
        map.setView([loc.lat, loc.lng], 12);
        showLocationInfo(loc);
        
      } catch (error) {
        console.error("Search error:", error);
        alert("Error searching location. Please try again.");
      } finally {
        showLoading(false);
      }
    }

    // Refresh Data
    function refreshData() {
      circles.forEach(c => map.removeLayer(c));
      circles = [];
      drawAlertZones();
      alert("Alert zones refreshed!");
    }

    // Show/hide loading indicator
    function showLoading(show) {
      loadingIndicator.style.display = show ? 'block' : 'none';
    }

    // Initialize
    window.onload = initMap;
  </script>
</body>
</html>